<?xml version="1.0" encoding="utf-8"?>
<topic id="6b377084-3fc9-4bf6-94d7-bc9a42ed82a7" revisionNumber="1">
  <developerConceptualDocument
    xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
    xmlns:xlink="http://www.w3.org/1999/xlink">

    <introduction>
      <para>实体仓库</para>
      <autoOutline />
    </introduction>
    <section address="sum">
      <title>简介</title>
      <content>
        <para>实体仓库是领域驱动设计中的重要概念，它的作用是管理实体，持久化并保存所有实体。实体的所有状态变更，都需要保存到仓库中去，包括新加实体、删除现有实体、修改实体的状态。同时，要获取任意一个实体，也需要通过实体仓库。</para>
        <para>
          关于 DDD 的概念，参考：<link xlink:href="f4f5c2f5-638a-456a-9c8d-1e1854c63002" />。
        </para>
      </content>
    </section>
    <section address="sum">
      <title>Respository模式在示例中的实际目的小结一下</title>
      <content>
        <list class="bullet">
          <listItem>
            <para>Repository模式是架构模式，在设计架构时，才有参考价值；</para>
          </listItem>
          <listItem>
            <para>Repository模式主要是封装数据查询和存储逻辑；</para>
          </listItem>
          <listItem>
            <para>Repository模式实际用途：更换、升级ORM 引擎，不影响业务逻辑；</para>
          </listItem>
          <listItem>
            <para>Repository模式能提高测试效率，单元测试时，用Mock对象代替实际的数据库存取，可以成倍地提高测试用例运行速度。</para>
          </listItem>
        </list>
      </content>
    </section>
    <section address="sum">
      <title>Repository与Dal的区别</title>
      <content>
        <list class="bullet">
          <listItem>
            <para> Repository是DDD中的概念，强调Repository是受Domain驱动的，Repository中定义的功能要体现Domain的意图和约束，而Dal更纯粹的就是提  供数据访问的功能,并不严格受限于Business层。</para>
          </listItem>
          <listItem>
            <para>使用Repository，隐含着一种意图倾向，就是 Domain需要什么我才提供什么，不该提供的功能就不要提供，一切都是以Domain的需求为核心；而使用Dal，其意图倾向在于我Dal层能使用的数 据库访问操作提供给Business层，你Business要用哪个自己选。换一个Business也可以用我这个Dal，一切是以我Dal能提供什么操 作为核心。</para>
          </listItem>
        </list>
      </content>
    </section>
    <section address="sum">
      <title>Repository模式设计</title>
      <content>
        <para>
          LCLFramework框架之Repository模式设计主要是参考http://apworks.codeplex.com/ 框架而来的，目前我只是扩展了LCL.Repositories.EntityFramework仓库，对于个人来使用已经足够了。
          <image xlink:href="Repository" />
        </para>
      </content>
    </section>
    <section address="sum">
      <title>仓库扩展</title>
      <content>
        <para>
          提供基于Entity Framework的仓储实现。在应用程序中使用这种仓储，也就基本涵盖了所有面向关系型数据库的对象持久化方案。不仅如此，开发人员还能根据项目的实际需求，对仓储实现进行扩展，以支持更多种类的对象持久化机制。
        </para>
        <list class="bullet">
          <listItem>
            <para>LCL.Repositories.EntityFramework.dll</para>
          </listItem>
          <listItem>
            <para>LCL.Repositories.MongoDB.dll</para>
          </listItem>
        </list>
      </content>
    </section>
    <section address="demo">
      <title>仓库类型</title>
      <content>
        <para>仓库类型代码示例如下：</para>
        <code language="cs">
          <![CDATA[
    public interface ITLogRepository : IRepository<TLog>
    {
        
    }
    public class TLogRepository : EntityFrameworkRepository<TLog>, ITLogRepository
    {
        public TLogRepository(IRepositoryContext context)
            : base(context)
        {

        }
    }
]]>
        </code>
        <para>
          仓库类型有以下特点：
        </para>
        <list class="bullet">
          <listItem>
            <para>每个实体都对应一个仓库类型。</para>
          </listItem>
          <listItem>
            <para>仓库类型必须遵守以下命名约定：仓库类型名称 = 实体类型名称 + "Repository"。</para>
          </listItem>
          <listItem>
            <para>
              仓库类型必须直接或间接继承自 <codeInline>Repository</codeInline> 类型。
            </para>
          </listItem>
          <listItem>
            <para>实体仓库，被设计为单例模式。</para>
            <para>即每个实体的仓库，在整个系统中只有唯一一个运行时对象。仓库类型的构建函数不能公开，通过仓库工厂来获取仓库对象。</para>
          </listItem>
        </list>
      </content>
    </section>
    <section address="factory">
      <title>仓库工厂</title>
      <content>
        <para>
          由于仓库是单例的，在整个系统运行时只存在一个对象。所以我们需要通过仓库工厂来获取唯一的这个仓库对象。
          <codeInline>RF</codeInline> 类型即是仓库工厂，全称是 RepositoryFactory。由于仓库工厂使用频率太大，所以使用拼音缩写。（另外，如果使用中觉得缩写不方便，框架提供了同样功能、全称的 RepositoryFactory 类型。）
        </para>
        <para>我们可以通过该类的以下两个方法来获取指定的仓库对象：</para>
        <list class="bullet">
          <listItem>
            <para>直接通过指定的仓库类型来获取其运行时仓库对象：</para>
            <para><![CDATA[public static TRepository Concrete<TRepository>() where TRepository : Repository]]></para>
          </listItem>
          <listItem>
            <para>通过实体类型来获取其唯一的仓库：</para>
            <para><![CDATA[public static EntityRepository Find(Type entityType)]]></para>
          </listItem>
        </list>
        <para>
          建议通过 <codeInline>Concrete</codeInline> 方法获取仓库，该方法经过优化，速度比 <codeInline>Find</codeInline> 方法要快许多。
        </para>
        <code language="cs">
          <![CDATA[CarRepository carRepo = RF.Concrete<CarRepository>();]]>
        </code>
      </content>
    </section>
    <relatedTopics>
    </relatedTopics>
  </developerConceptualDocument>
</topic>
